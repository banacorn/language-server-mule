// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("rescript/lib/js/curry.js");
var $$String = require("rescript/lib/js/string.js");
var $$Promise = require("reason-promise/src/js/promise.bs.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Child_process = require("child_process");
var Util$LanguageServerMule = require("./Util/Util.bs.js");

function toString(x) {
  if (typeof x === "number") {
    if (x === /* NotResponding */0) {
      return "Took more than 1 second to when looking for the executable";
    } else {
      return "Cannot find the executalbe";
    }
  }
  switch (x.TAG | 0) {
    case /* NotSupported */0 :
        return "Path searching is not supported on \"" + x._0 + "\"";
    case /* OnError */1 :
        return "Got error when looking for the executable: " + Util$LanguageServerMule.JsError.toString(x._0);
    case /* OnStderr */2 :
        return "Got something from the stderr when looking for the executable: " + x._0;
    
  }
}

var $$Error = {
  toString: toString
};

function run(name) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, {
                      TAG: /* Error */1,
                      _0: /* NotResponding */0
                    });
        }), 1000);
  var os = Os.type();
  var whichCommand;
  switch (os) {
    case "Darwin" :
    case "Linux" :
        whichCommand = {
          TAG: /* Ok */0,
          _0: "which"
        };
        break;
    case "Windows_NT" :
        whichCommand = {
          TAG: /* Ok */0,
          _0: "where.exe"
        };
        break;
    default:
      whichCommand = {
        TAG: /* Error */1,
        _0: os
      };
  }
  if (whichCommand.TAG === /* Ok */0) {
    Child_process.exec(whichCommand._0 + (" " + name), (function (error, stdout, stderr) {
            clearTimeout(hangTimeout);
            Belt_Option.forEach((error == null) ? undefined : Caml_option.some(error), (function (err) {
                    return Curry._1(resolve, {
                                TAG: /* Error */1,
                                _0: {
                                  TAG: /* OnError */1,
                                  _0: err
                                }
                              });
                  }));
            var stderr$1 = stderr.toString();
            if (stderr$1 !== "") {
              Curry._1(resolve, {
                    TAG: /* Error */1,
                    _0: {
                      TAG: /* OnStderr */2,
                      _0: stderr$1
                    }
                  });
            }
            var stdout$1 = $$String.trim(stdout.toString());
            if (stdout$1 === "") {
              return Curry._1(resolve, {
                          TAG: /* Error */1,
                          _0: /* NotFound */1
                        });
            } else {
              return Curry._1(resolve, {
                          TAG: /* Ok */0,
                          _0: stdout$1
                        });
            }
          }));
  } else {
    Curry._1(resolve, {
          TAG: /* Error */1,
          _0: {
            TAG: /* NotSupported */0,
            _0: whichCommand._0
          }
        });
  }
  return match[0];
}

var Module = {
  run: run
};

exports.$$Error = $$Error;
exports.Module = Module;
exports.run = run;
/* os Not a pure module */
