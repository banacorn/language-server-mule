// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var $$Promise = require("reason-promise/src/js/promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Child_process = require("child_process");
var Chan$LanguageServerMule = require("./Util/Chan.bs.js");
var Util$LanguageServerMule = require("./Util/Util.bs.js");

function toString(x) {
  if (typeof x === "number") {
    return [
            "Process hanging",
            "The program has not been responding for more than 1 sec"
          ];
  }
  switch (x.TAG | 0) {
    case /* PathMalformed */0 :
        return [
                "Path malformed",
                x._0
              ];
    case /* NotFound */1 :
        return [
                "Command not found",
                Util$LanguageServerMule.JsError.toString(x._0)
              ];
    case /* ShellError */2 :
        return [
                "Error from the shell",
                Util$LanguageServerMule.JsError.toString(x._0)
              ];
    case /* ProcessError */3 :
        return [
                "Error from the stderr",
                x._0
              ];
    case /* WrongProcess */4 :
        return [
                "Wrong process",
                x._0
              ];
    
  }
}

var $$Error = {
  toString: toString
};

function run(path, validator) {
  var parseError = function (error) {
    return Belt_Option.map((error == null) ? undefined : Caml_option.some(error), (function (err) {
                  var message = Belt_Option.getWithDefault(err.message, "");
                  if (/No such file or directory/.test(message) || /command not found/.test(message)) {
                    return {
                            TAG: /* NotFound */1,
                            _0: err
                          };
                  } else {
                    return {
                            TAG: /* ShellError */2,
                            _0: err
                          };
                  }
                }));
  };
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  if (path === "") {
    Curry._1(resolve, {
          TAG: /* Error */1,
          _0: {
            TAG: /* PathMalformed */0,
            _0: "the path must not be empty"
          }
        });
  }
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, {
                      TAG: /* Error */1,
                      _0: /* ProcessHanging */0
                    });
        }), 20000);
  Child_process.exec(path, (function (error, stdout, stderr) {
          clearTimeout(hangTimeout);
          Belt_Option.forEach(parseError(error), (function (err) {
                  return Curry._1(resolve, {
                              TAG: /* Error */1,
                              _0: err
                            });
                }));
          var stderr$1 = stderr.toString();
          if (stderr$1 !== "") {
            Curry._1(resolve, {
                  TAG: /* Error */1,
                  _0: {
                    TAG: /* ProcessError */3,
                    _0: stderr$1
                  }
                });
          }
          var stdout$1 = stdout.toString();
          var err = Curry._1(validator, stdout$1);
          if (err.TAG === /* Ok */0) {
            return Curry._1(resolve, {
                        TAG: /* Ok */0,
                        _0: err._0
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: /* Error */1,
                        _0: {
                          TAG: /* WrongProcess */4,
                          _0: err._0
                        }
                      });
          }
        }));
  return match[0];
}

var Validation = {
  $$Error: $$Error,
  run: run
};

function toString$1(x) {
  if (typeof x === "number") {
    return [
            "Disconnected",
            "Connection disconnected by ourselves"
          ];
  }
  switch (x.TAG | 0) {
    case /* ClosedByProcess */0 :
        var args = Belt_Array.joinWith(x._1, " ", (function (x) {
                return x;
              }));
        return [
                "Socket closed by process",
                "exited with code: " + x._2 + "\npath: " + x._0 + "\nargs: " + args + "\n"
              ];
    case /* ShellError */1 :
        return [
                "Socket error",
                Util$LanguageServerMule.JsError.toString(x._0)
              ];
    case /* ExitedByProcess */2 :
        var args$1 = Belt_Array.joinWith(x._1, " ", (function (x) {
                return x;
              }));
        return [
                "Agda has crashed !",
                "exited with code: " + x._2 + "\n  path: " + x._0 + "\n  args: " + args$1 + "\n  === message from stderr ===\n  " + x._3 + "\n  "
              ];
    
  }
}

var $$Event = {
  toString: toString$1
};

function make(path, args) {
  var chan = Chan$LanguageServerMule.make(undefined);
  var stderr = {
    contents: ""
  };
  var $$process = Child_process.spawn("\"" + (path + "\""), args, {shell : true});
  Belt_Option.forEach(Caml_option.nullable_to_opt($$process.stdout), (function (stream) {
          stream.on("data", (function (chunk) {
                  return Chan$LanguageServerMule.emit(chan, {
                              TAG: /* Stdout */0,
                              _0: chunk.toString()
                            });
                }));
          
        }));
  Belt_Option.forEach(Caml_option.nullable_to_opt($$process.stderr), (function (stream) {
          stream.on("data", (function (chunk) {
                  Chan$LanguageServerMule.emit(chan, {
                        TAG: /* Stderr */1,
                        _0: chunk.toString()
                      });
                  stderr.contents = chunk.toString();
                  
                }));
          
        }));
  Belt_Option.forEach(Caml_option.nullable_to_opt($$process.stdin), (function (stream) {
          stream.on("close", (function () {
                  return Chan$LanguageServerMule.emit(chan, {
                              TAG: /* Event */2,
                              _0: {
                                TAG: /* ClosedByProcess */0,
                                _0: path,
                                _1: args,
                                _2: 0
                              }
                            });
                }));
          
        }));
  $$process.on("close", (function (code) {
                return Chan$LanguageServerMule.emit(chan, {
                            TAG: /* Event */2,
                            _0: {
                              TAG: /* ClosedByProcess */0,
                              _0: path,
                              _1: args,
                              _2: code
                            }
                          });
              })).on("disconnect", (function () {
              return Chan$LanguageServerMule.emit(chan, {
                          TAG: /* Event */2,
                          _0: /* DisconnectedByUser */0
                        });
            })).on("error", (function (exn) {
            return Chan$LanguageServerMule.emit(chan, {
                        TAG: /* Event */2,
                        _0: {
                          TAG: /* ShellError */1,
                          _0: exn
                        }
                      });
          })).on("exit", (function (code) {
          if (code !== 0) {
            return Chan$LanguageServerMule.emit(chan, {
                        TAG: /* Event */2,
                        _0: {
                          TAG: /* ExitedByProcess */2,
                          _0: path,
                          _1: args,
                          _2: code,
                          _3: stderr.contents
                        }
                      });
          }
          
        }));
  return {
          chan: chan,
          status: {
            TAG: /* Created */0,
            _0: $$process
          }
        };
}

function destroy(self) {
  var $$process = self.status;
  if (typeof $$process === "number") {
    return $$Promise.resolved(undefined);
  }
  if ($$process.TAG !== /* Created */0) {
    return $$process._0;
  }
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var promise = match[0];
  self.status = {
    TAG: /* Destroying */1,
    _0: promise
  };
  Chan$LanguageServerMule.on(self.chan, (function (x) {
          switch (x.TAG | 0) {
            case /* Stdout */0 :
            case /* Stderr */1 :
                return ;
            case /* Event */2 :
                var tmp = x._0;
                if (typeof tmp === "number") {
                  return ;
                }
                if (tmp.TAG !== /* ExitedByProcess */2) {
                  return ;
                }
                Chan$LanguageServerMule.destroy(self.chan);
                self.status = /* Destroyed */0;
                return Curry._1(resolve, undefined);
            
          }
        }));
  $$process._0.kill("SIGTERM");
  return promise;
}

function send(self, request) {
  var $$process = self.status;
  if (typeof $$process === "number") {
    return false;
  }
  if ($$process.TAG !== /* Created */0) {
    return false;
  }
  var payload = Buffer.from(request + "\n");
  Belt_Option.forEach(Caml_option.nullable_to_opt($$process._0.stdin), (function (stream) {
          stream.write(payload);
          
        }));
  return true;
}

function onOutput(self, callback) {
  return Chan$LanguageServerMule.on(self.chan, (function (output) {
                switch (output.TAG | 0) {
                  case /* Stdout */0 :
                  case /* Stderr */1 :
                      return Curry._1(callback, output);
                  case /* Event */2 :
                      var tmp = output._0;
                      if (typeof tmp === "number") {
                        return Curry._1(callback, output);
                      }
                      if (tmp.TAG !== /* ExitedByProcess */2) {
                        return Curry._1(callback, output);
                      }
                      var match = self.status;
                      if (typeof match === "number" || match.TAG === /* Created */0) {
                        return Curry._1(callback, output);
                      } else {
                        return ;
                      }
                  
                }
              }));
}

var Module = {
  make: make,
  destroy: destroy,
  send: send,
  onOutput: onOutput
};

exports.Validation = Validation;
exports.$$Event = $$Event;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.send = send;
exports.onOutput = onOutput;
/* Promise Not a pure module */
